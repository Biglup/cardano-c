name: Generate Release

on:
  release:
    types: [created]

permissions:
  contents: read

jobs:
  build-and-release:
    permissions:
      contents: write
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        include:
          # Ubuntu
          - os: ubuntu-latest
            arch: x86_64
            compiler: gcc
          - os: ubuntu-latest
            arch: arm64
            compiler: gcc
          # macOS
          - os: macos-latest
            arch: x86_64
            compiler: gcc
          - os: macos-latest
            arch: arm64
            compiler: gcc
          # Windows
          - os: windows-latest
            arch: x86_64
            compiler: msvc
          - os: windows-latest
            arch: x86_64
            compiler: mingw

    name: Build on ${{ matrix.os }} for ${{ matrix.arch }} using ${{ matrix.compiler }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Read version on Unix-based systems
      - name: Read version (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          source VERSION
          echo "VERSION_MAJOR=$VERSION_MAJOR" >> $GITHUB_ENV
          echo "VERSION_MINOR=$VERSION_MINOR" >> $GITHUB_ENV
          echo "VERSION_PATCH=$VERSION_PATCH" >> $GITHUB_ENV
          echo "VERSION=$VERSION_MAJOR.$VERSION_MINOR.$VERSION_PATCH" >> $GITHUB_ENV

      # Read version on Windows systems
      - name: Read version (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $versionContent = Get-Content VERSION
          foreach ($line in $versionContent) {
            if ($line -match 'VERSION_MAJOR=(.*)') { $env:VERSION_MAJOR = $Matches[1] }
            if ($line -match 'VERSION_MINOR=(.*)') { $env:VERSION_MINOR = $Matches[1] }
            if ($line -match 'VERSION_PATCH=(.*)') { $env:VERSION_PATCH = $Matches[1] }
          }
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION_MAJOR=$($env:VERSION_MAJOR)"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION_MINOR=$($env:VERSION_MINOR)"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION_PATCH=$($env:VERSION_PATCH)"
          Add-Content -Path $env:GITHUB_ENV -Value "VERSION=$($env:VERSION_MAJOR).$($env:VERSION_MINOR).$($env:VERSION_PATCH)"

      # Set Release Name on Unix systems
      - name: Set Release Name (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          echo "RELEASE_NAME=library-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.compiler }}" >> $GITHUB_ENV

      # Set Release Name on Windows systems
      - name: Set Release Name (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Add-Content -Path $env:GITHUB_ENV -Value "RELEASE_NAME=library-${{ matrix.os }}-${{ matrix.arch }}-${{ matrix.compiler }}"

      # Install dependencies for Unix
      - name: Install dependencies (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            sudo apt-get update
            case "${{ matrix.arch }}" in
              arm64) sudo apt-get install -y gcc-aarch64-linux-gnu ;;
            esac
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            # CMake is already installed on macOS runners
            cmake --version
          fi

      # Install dependencies for Windows
      - name: Install dependencies (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if ("${{ matrix.compiler }}" -eq 'mingw') {
            Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12
            iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
            choco install -y mingw
            # Add MinGW to PATH
            "C:\tools\mingw64\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          }

      # Setup MSVC environment
      - name: Setup MSVC environment
        if: runner.os == 'Windows' && matrix.compiler == 'msvc'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      # Build on Unix systems
      - name: Build (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          mkdir -p build
          cd build
          case "${{ matrix.arch }}" in
            arm64)
              cmake -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
                -DVERSION_MAJOR=${{ env.VERSION_MAJOR }} \
                -DVERSION_MINOR=${{ env.VERSION_MINOR }} \
                -DVERSION_PATCH=${{ env.VERSION_PATCH }} \
                -DCMAKE_BUILD_TYPE=Release \
                ..
              ;;
            x86_64)
              cmake -DCMAKE_SYSTEM_PROCESSOR=x86_64 \
                -DVERSION_MAJOR=${{ env.VERSION_MAJOR }} \
                -DVERSION_MINOR=${{ env.VERSION_MINOR }} \
                -DVERSION_PATCH=${{ env.VERSION_PATCH }} \
                -DCMAKE_BUILD_TYPE=Release \
                ..
              ;;
          esac
          cmake --build . --config Release
          cd ..  # Return to repository root

      # Build on Windows MSVC
      - name: Build (Windows MSVC)
        if: runner.os == 'Windows' && matrix.compiler == 'msvc'
        shell: cmd
        run: |
          mkdir build
          cd build
          cmake -G "Visual Studio 17 2022" -A x64 ^
            -DVERSION_MAJOR=%VERSION_MAJOR% ^
            -DVERSION_MINOR=%VERSION_MINOR% ^
            -DVERSION_PATCH=%VERSION_PATCH% ^
            ..
          cmake --build . --config Release
          cd ..

      # Build on Windows MinGW
      - name: Build (Windows MinGW)
        if: runner.os == 'Windows' && matrix.compiler == 'mingw'
        shell: bash
        run: |
          mkdir -p build
          cd build
          cmake -G "MinGW Makefiles" \
            -DVERSION_MAJOR=${{ env.VERSION_MAJOR }} \
            -DVERSION_MINOR=${{ env.VERSION_MINOR }} \
            -DVERSION_PATCH=${{ env.VERSION_PATCH }} \
            -DCMAKE_BUILD_TYPE=Release \
            ..
          cmake --build . --config Release
          cd ..

      # Package binaries (Unix)
      - name: Package binaries (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          RELEASE_DIR=release/${{ env.RELEASE_NAME }}
          mkdir -p $RELEASE_DIR
          cp -r lib/include $RELEASE_DIR/
          cp build/release/lib/* $RELEASE_DIR/ 2>/dev/null || true
          tar -czf "release-${{ env.RELEASE_NAME }}.tar.gz" -C release/${{ env.RELEASE_NAME }} .

      # Package binaries (Windows MSVC)
      - name: Package binaries (Windows MSVC)
        if: runner.os == 'Windows' && matrix.compiler == 'msvc'
        shell: cmd
        run: |
          set RELEASE_DIR=release\%RELEASE_NAME%
          mkdir %RELEASE_DIR%
          xcopy /E /I lib\include %RELEASE_DIR%\include
          xcopy /Y build\release\lib\* %RELEASE_DIR%\
          powershell Compress-Archive -Path %RELEASE_DIR%\* -DestinationPath release-%RELEASE_NAME%.zip

      # Package binaries (Windows MinGW)
      - name: Package binaries (Windows MinGW)
        if: runner.os == 'Windows' && matrix.compiler == 'mingw'
        shell: bash
        run: |
          RELEASE_DIR=release/${{ env.RELEASE_NAME }}
          mkdir -p $RELEASE_DIR
          cp -r lib/include $RELEASE_DIR/
          cp build/release/lib/* $RELEASE_DIR/ 2>/dev/null || true
          7z a "release-${{ env.RELEASE_NAME }}.zip" $RELEASE_DIR

      # Upload artifacts to GitHub Release (Unix)
      - name: Upload artifacts to GitHub Release (Unix)
        if: runner.os != 'Windows'
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release-${{ env.RELEASE_NAME }}.tar.gz
          asset_name: release-${{ env.RELEASE_NAME }}.tar.gz
          asset_content_type: application/gzip

      # Upload artifacts to GitHub Release (Windows)
      - name: Upload artifacts to GitHub Release (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release-${{ env.RELEASE_NAME }}.zip
          asset_name: release-${{ env.RELEASE_NAME }}.zip
          asset_content_type: application/zip
