/**
 * \file transaction_body.cpp
 *
 * \author angel.castillo
 * \date   Sep 18, 2024
 *
 * Copyright 2024 Biglup Labs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* INCLUDES ******************************************************************/

#include <cardano/error.h>

#include <cardano/cbor/cbor_reader.h>
#include <cardano/crypto/blake2b_hash.h>
#include <cardano/transaction_body/transaction_body.h>

#include "tests/allocators_helpers.h"

#include <allocators.h>

#include <gmock/gmock.h>

/* CONSTANTS *****************************************************************/

static const char* CBOR_HASH                  = "ae0f9e09ffe9fdd6b9a1ce7aea9a2833b0e17886806c45858c53b408778e52a2";
static const char* CONWAY_CBOR_HASH           = "9a5c335b16a14454b23c959160e07e52fe0626fa7d012e5abdf3a11a4a31aec7";
static const char* CONWAY_CBOR_WITH_SETS_HASH = "404fb9933b9edef0ac162fc1470ac2674ee66705c3fbcb854f4822470c41a45e";
static const char* CBOR                       = "b100818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d5000181825839009493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e32c728d3861e164cab28cb8f006448139c8f1740ffb8e7aa9e5232dc820aa3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c411832581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e020a031903e804828304581c26b17b78de4f035dc0bfce60d1d3c3a8085c38dcce5fb8767e518bed1901f48405581c0d94e174732ef9aae73f395ab44507bfa983d65023c11a951f0c32e4581ca646474b8f5431261506b6c273d307c7569a4eb6c96b42dd4a29520a582003170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131405a2581de013cf55d175ea848b87deb3e914febd7e028e2bf6534475d52fb9c3d005581de0404b5a4088ae9abcf486a7e7b8f82069e6fcfe1bf226f1851ce72570030682a3581c00000000000000000000000000000000000000000000000000000001b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000002b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000003b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba19020b0758202ceb364d93225b4a0f004a0975a13eb50c3cc6348474b4fe9121f8dc72ca0cfa08186409a3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c413831581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e0b58206199186adb51974690d7247d2646097d2c62763b16fb7ed3f9f55d38abc123de0d818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d5010e81581c6199186adb51974690d7247d2646097d2c62763b16fb7ed3f9f55d390f0110825839009493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e32c728d3861e164cab28cb8f006448139c8f1740ffb8e7aa9e5232dc820aa3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c411832581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e11186412818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d500";
static const char* CONWAY_CBOR                = "b500818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d5000181825839009493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e32c728d3861e164cab28cb8f006448139c8f1740ffb8e7aa9e5232dc820aa3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c411832581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e020a031903e804828304581c26b17b78de4f035dc0bfce60d1d3c3a8085c38dcce5fb8767e518bed1901f48405581c0d94e174732ef9aae73f395ab44507bfa983d65023c11a951f0c32e4581ca646474b8f5431261506b6c273d307c7569a4eb6c96b42dd4a29520a582003170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131405a2581de013cf55d175ea848b87deb3e914febd7e028e2bf6534475d52fb9c3d005581de0404b5a4088ae9abcf486a7e7b8f82069e6fcfe1bf226f1851ce72570030682a3581c00000000000000000000000000000000000000000000000000000001b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000002b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000003b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba19020b0758202ceb364d93225b4a0f004a0975a13eb50c3cc6348474b4fe9121f8dc72ca0cfa08186409a3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c413831581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e0b58206199186adb51974690d7247d2646097d2c62763b16fb7ed3f9f55d38abc123de0d818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d5010e81581c6199186adb51974690d7247d2646097d2c62763b16fb7ed3f9f55d390f0110825839009493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e32c728d3861e164cab28cb8f006448139c8f1740ffb8e7aa9e5232dc820aa3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c411832581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e11186412818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d50013a28202581c10000000000000000000000000000000000000000000000000000000a38258201000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258202000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258203000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008203581c20000000000000000000000000000000000000000000000000000000a28258201000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258203000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000001481841a000f4240581de1cb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f830582582000000000000000000000000000000000000000000000000000000000000000000382827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000f6827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000151907d0161903e8";
static const char* CONWAY_CBOR_WITH_SETS      = "b500d90102818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d5000181a2005839009493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e32c728d3861e164cab28cb8f006448139c8f1740ffb8e7aa9e5232dc01820aa3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c411832581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e020a031903e804d90102828304581c26b17b78de4f035dc0bfce60d1d3c3a8085c38dcce5fb8767e518bed1901f48405581c0d94e174732ef9aae73f395ab44507bfa983d65023c11a951f0c32e4581ca646474b8f5431261506b6c273d307c7569a4eb6c96b42dd4a29520a582003170a2e7597b7b7e3d84c05391d139a62b157e78786d8c082f29dcf4c11131405a2581de013cf55d175ea848b87deb3e914febd7e028e2bf6534475d52fb9c3d005581de0404b5a4088ae9abcf486a7e7b8f82069e6fcfe1bf226f1851ce72570030682a3581c00000000000000000000000000000000000000000000000000000001b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000002b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000003b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a10098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba19020b0758202ceb364d93225b4a0f004a0975a13eb50c3cc6348474b4fe9121f8dc72ca0cfa08186409a3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c413831581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e0b58206199186adb51974690d7247d2646097d2c62763b16fb7ed3f9f55d38abc123de0dd90102818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d5010ed9010281581c6199186adb51974690d7247d2646097d2c62763b16fb7ed3f9f55d390f0110a2005839009493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e32c728d3861e164cab28cb8f006448139c8f1740ffb8e7aa9e5232dc01820aa3581c2a286ad895d091f2b3d168a6091ad2627d30a72761a5bc36eef00740a14014581c659f2917fb63f12b33667463ee575eeac1845bbc736b9c0bbc40ba82a14454534c411832581c7eae28af2208be856f7a119668ae52a49b73725e326dc16579dcc373a240182846504154415445181e11186412d90102818258200f3abbc8fc19c2e61bab6059bf8a466e6e754833a08a62a6c56fe0e78f19d9d50013a28202581c10000000000000000000000000000000000000000000000000000000a38258201000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258202000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258203000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008203581c20000000000000000000000000000000000000000000000000000000a28258201000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258203000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f5820000000000000000000000000000000000000000000000000000000000000000014d9010281841a000f4240581de1cb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f830582582000000000000000000000000000000000000000000000000000000000000000000382827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000f6827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000151907d0161903e8";
static const char* INPUT_SET_CBOR             = "d90102848258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001020058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001021058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001022058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a09080706050403020100102305";
static const char* OUTPUT_LIST_CBOR           = "84a400583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ff03d8185182014e4d01000033222220051200120011a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a02820058200000000000000000000000000000000000000000000000000000000000000000a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ffa2005826412813b99a80cfb4024374bd0f502959485aa56e0648564ff805f2e51b8cd9819561bddc6614011a02faf080";
static const char* SMALL_BODY_CBOR            = "a400d90102848258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001020058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001021058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001022058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001023050184a400583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ff03d8185182014e4d01000033222220051200120011a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a02820058200000000000000000000000000000000000000000000000000000000000000000a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ffa2005826412813b99a80cfb4024374bd0f502959485aa56e0648564ff805f2e51b8cd9819561bddc6614011a02faf0800218640319fde8";
static const char* SMALL_BODY_NO_TTL_CBOR     = "a300d90102848258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001020058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001021058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001022058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001023050184a400583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ff03d8185182014e4d01000033222220051200120011a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a02820058200000000000000000000000000000000000000000000000000000000000000000a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ffa2005826412813b99a80cfb4024374bd0f502959485aa56e0648564ff805f2e51b8cd9819561bddc6614011a02faf080021864";
static const char* CERTIFICATES_CBOR          = "d901028483078200581c000000000000000000000000000000000000000000000000000000000083088200581c0000000000000000000000000000000000000000000000000000000000830f8200581c00000000000000000000000000000000000000000000000000000000f683028200581ccb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f581cd85087c646951407198c27b1b950fd2e99f28586c000ce39f6e6ef92";
static const char* WITHDRAWALS_CBOR           = "a1581de013cf55d175ea848b87deb3e914febd7e028e2bf6534475d52fb9c3d005";
static const char* UPDATE_CBOR                = "82a3581c00000000000000000000000000000000000000000000000000000001b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a20098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a0198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0223accc0a1a0374f693194a1f0a1a02515e841980b30a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000002b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a20098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a0198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0223accc0a1a0374f693194a1f0a1a02515e841980b30a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba581c00000000000000000000000000000000000000000000000000000003b60018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d8201582000000000000000000000000000000000000000000000000000000000000000000e820103101903e8111988b812a20098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a0198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0223accc0a1a0374f693194a1f0a1a02515e841980b30a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba19020b";
static const char* HASH_CBOR                  = "581c00000000000000000000000000000000000000000000000000000000";
static const char* MINT_CBOR                  = "a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a";
static const char* HASH_SET_CBOR              = "d9010284581c00000000000000000000000000000000000000000000000000000001581c00000000000000000000000000000000000000000000000000000002581c00000000000000000000000000000000000000000000000000000003581c00000000000000000000000000000000000000000000000000000004";
static const char* OUTPUT_CBOR                = "a400583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ff03d8185182014e4d01000033222220051200120011";
static const char* VOTING_PROCEDURES_CBOR     = "a28202581c10000000000000000000000000000000000000000000000000000000a38258201000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258202000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258203000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008203581c20000000000000000000000000000000000000000000000000000000a28258201000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f582000000000000000000000000000000000000000000000000000000000000000008258203000000000000000000000000000000000000000000000000000000000000000038200827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000";
static const char* PROPOSAL_PROCEDURE_CBOR    = "d9010284841a000f4240581de1cb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f8400825820000000000000000000000000000000000000000000000000000000000000000003b81f0018640118c80219012c03190190041901f4051a001e8480061a0bebc200071903200819038409d81e8201020ad81e8201030bd81e8201040cd81e8201050d820158200000000000000000000000000000000000000000000000000000000000000000101903e8111988b812a20098a61a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0374f693194a1f0a0198af1a0003236119032c01011903e819023b00011903e8195e7104011903e818201a0001ca761928eb041959d818641959d818641959d818641959d818641959d818641959d81864186418641959d81864194c5118201a0002acfa182019b551041a000363151901ff00011a00015c3518201a000797751936f404021a0002ff941a0006ea7818dc0001011903e8196ff604021a0003bd081a00034ec5183e011a00102e0f19312a011a00032e801901a5011a0002da781903e819cf06011a00013a34182019a8f118201903e818201a00013aac0119e143041903e80a1a00030219189c011a00030219189c011a0003207c1901d9011a000330001901ff0119ccf3182019fd40182019ffd5182019581e18201940b318201a00012adf18201a0002ff941a0006ea7818dc0001011a00010f92192da7000119eabb18201a0002ff941a0006ea7818dc0001011a0002ff941a0006ea7818dc0001011a0011b22c1a0005fdde00021a000c504e197712041a001d6af61a0001425b041a00040c660004001a00014fab18201a0003236119032c010119a0de18201a00033d7618201979f41820197fb8182019a95d1820197df718201995aa18201a0223accc0a1a0374f693194a1f0a1a02515e841980b30a1382d81e820102d81e82010214821b00000001000000001b000000010000000015821b00000001000000001b0000000100000000161903ba1719035418181864181985d81e820000d81e820101d81e820202d81e820303d81e820101181a8ad81e820000d81e820101d81e820202d81e820303d81e820404d81e820505d81e820606d81e820707d81e820808d81e820909181b1864181c18c8181d19012c181e1903e8181f1907d01820191388581c8293d319ef5b3ac72366dd28006bd315b715f7e7cfcbd3004129b80d827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000841a000f4240581de1cb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f8301825820000000000000000000000000000000000000000000000000000000000000000003820103827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000841a000f4240581de1cb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f8302a1581de1cb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f01581c8293d319ef5b3ac72366dd28006bd315b715f7e7cfcbd3004129b80d827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000841a000f4240581de1cb0ec2692497b458e46812c8a5bfa2931d1a2d965a99893828ec810f8203825820000000000000000000000000000000000000000000000000000000000000000003827668747470733a2f2f7777772e736f6d6575726c2e696f58200000000000000000000000000000000000000000000000000000000000000000";

/* STATIC FUNCTIONS **********************************************************/

/**
 * Creates a new default instance of the transaction_body.
 * @return A new instance of the transaction_body.
 */
static cardano_transaction_body_t*
new_default_transaction_body()
{
  cardano_transaction_body_t* transaction_body = NULL;
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(CONWAY_CBOR_WITH_SETS, strlen(CONWAY_CBOR_WITH_SETS));
  cardano_error_t             result           = cardano_transaction_body_from_cbor(reader, &transaction_body);

  EXPECT_THAT(result, CARDANO_SUCCESS);

  cardano_cbor_reader_unref(&reader);

  cardano_transaction_body_clear_cbor_cache(transaction_body);

  return transaction_body;
};

/* UNIT TESTS ****************************************************************/

TEST(cardano_transaction_body_ref, increasesTheReferenceCount)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_body_ref(transaction_body);

  // Assert
  EXPECT_THAT(transaction_body, testing::Not((cardano_transaction_body_t*)nullptr));
  EXPECT_EQ(cardano_transaction_body_refcount(transaction_body), 2);

  // Cleanup - We need to unref twice since one reference was added.
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_ref, doesntCrashIfGivenANullPtr)
{
  // Act
  cardano_transaction_body_ref(nullptr);
}

TEST(cardano_transaction_body_unref, doesntCrashIfGivenAPtrToANullPtr)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = nullptr;

  // Act
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_unref, doesntCrashIfGivenANullPtr)
{
  // Act
  cardano_transaction_body_unref((cardano_transaction_body_t**)nullptr);
}

TEST(cardano_transaction_body_unref, decreasesTheReferenceCount)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_body_ref(transaction_body);
  size_t ref_count = cardano_transaction_body_refcount(transaction_body);

  cardano_transaction_body_unref(&transaction_body);
  size_t updated_ref_count = cardano_transaction_body_refcount(transaction_body);

  // Assert
  EXPECT_EQ(ref_count, 2);
  EXPECT_EQ(updated_ref_count, 1);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_unref, freesTheObjectIfReferenceReachesZero)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_body_ref(transaction_body);
  size_t ref_count = cardano_transaction_body_refcount(transaction_body);

  cardano_transaction_body_unref(&transaction_body);
  size_t updated_ref_count = cardano_transaction_body_refcount(transaction_body);

  cardano_transaction_body_unref(&transaction_body);

  // Assert
  EXPECT_EQ(ref_count, 2);
  EXPECT_EQ(updated_ref_count, 1);
  EXPECT_EQ(transaction_body, (cardano_transaction_body_t*)nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_refcount, returnsZeroIfGivenANullPtr)
{
  // Act
  size_t ref_count = cardano_transaction_body_refcount(nullptr);

  // Assert
  EXPECT_EQ(ref_count, 0);
}

TEST(cardano_transaction_body_set_last_error, doesNothingWhenObjectIsNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = nullptr;
  const char*                 message          = "This is a test message";

  // Act
  cardano_transaction_body_set_last_error(transaction_body, message);

  // Assert
  EXPECT_STREQ(cardano_transaction_body_get_last_error(transaction_body), "Object is NULL.");
}

TEST(cardano_transaction_body_set_last_error, doesNothingWhenWhenMessageIsNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  const char* message = nullptr;

  // Act
  cardano_transaction_body_set_last_error(transaction_body, message);

  // Assert
  EXPECT_STREQ(cardano_transaction_body_get_last_error(transaction_body), "");

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_from_cbor, returnsErrorIfReaderIsNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_from_cbor(nullptr, &transaction_body);

  // Assert
  ASSERT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_from_cbor, returnsErrorIfTransactionBodyIsNull)
{
  // Arrange
  cardano_cbor_reader_t* reader = cardano_cbor_reader_from_hex(CBOR, strlen(CBOR));

  // Act
  cardano_error_t result = cardano_transaction_body_from_cbor(reader, nullptr);

  // Assert
  ASSERT_EQ(result, CARDANO_POINTER_IS_NULL);

  // Cleanup
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_to_cbor, canSerialize)
{
  // Arrange
  cardano_cbor_writer_t*      writer = cardano_cbor_writer_new();
  cardano_transaction_body_t* cert   = new_default_transaction_body();
  EXPECT_NE(cert, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_to_cbor(cert, writer);

  // Assert
  ASSERT_EQ(result, CARDANO_SUCCESS);

  size_t hex_size = cardano_cbor_writer_get_hex_size(writer);
  char*  hex      = (char*)malloc(hex_size);

  ASSERT_EQ(cardano_cbor_writer_encode_hex(writer, hex, hex_size), CARDANO_SUCCESS);

  EXPECT_STREQ(hex, CONWAY_CBOR_WITH_SETS);

  // Cleanup
  cardano_transaction_body_unref(&cert);
  cardano_cbor_writer_unref(&writer);
  free(hex);
}

TEST(cardano_transaction_body_to_cbor, returnsErrorIfTransactionBodyIsNull)
{
  // Arrange
  cardano_cbor_writer_t* writer = cardano_cbor_writer_new();

  // Act
  cardano_error_t result = cardano_transaction_body_to_cbor(nullptr, writer);

  // Assert
  ASSERT_EQ(result, CARDANO_POINTER_IS_NULL);

  // Cleanup
  cardano_cbor_writer_unref(&writer);
}

TEST(cardano_transaction_body_to_cbor, returnsErrorIfWriterIsNull)
{
  // Act
  cardano_error_t result = cardano_transaction_body_to_cbor((cardano_transaction_body_t*)"", nullptr);

  // Assert
  ASSERT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_new, canCreateNewInstance)
{
  // Act
  cardano_transaction_input_set_t*   inputs           = NULL;
  cardano_transaction_output_list_t* outputs          = NULL;
  const uint64_t                     fee              = 100;
  const uint64_t                     ttl              = 65000;
  cardano_transaction_body_t*        transaction_body = NULL;
  cardano_cbor_reader_t*             inputs_reader    = cardano_cbor_reader_from_hex(INPUT_SET_CBOR, strlen(INPUT_SET_CBOR));
  cardano_cbor_reader_t*             outputs_reader   = cardano_cbor_reader_from_hex(OUTPUT_LIST_CBOR, strlen(OUTPUT_LIST_CBOR));

  EXPECT_THAT(cardano_transaction_input_set_from_cbor(inputs_reader, &inputs), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_transaction_output_list_from_cbor(outputs_reader, &outputs), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_transaction_body_new(inputs, outputs, fee, &ttl, &transaction_body), CARDANO_SUCCESS);

  // Assert
  cardano_cbor_writer_t* writer = cardano_cbor_writer_new();
  EXPECT_THAT(cardano_transaction_body_to_cbor(transaction_body, writer), CARDANO_SUCCESS);

  size_t hex_size = cardano_cbor_writer_get_hex_size(writer);
  char*  hex      = (char*)malloc(hex_size);

  ASSERT_EQ(cardano_cbor_writer_encode_hex(writer, hex, hex_size), CARDANO_SUCCESS);

  EXPECT_STREQ(hex, SMALL_BODY_CBOR);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&inputs);
  cardano_transaction_output_list_unref(&outputs);
  cardano_cbor_reader_unref(&inputs_reader);
  cardano_cbor_reader_unref(&outputs_reader);
  cardano_cbor_writer_unref(&writer);
  free(hex);
}

TEST(cardano_transaction_body_new, canCreateNewInstanceNullTTL)
{
  // Act
  cardano_transaction_input_set_t*   inputs           = NULL;
  cardano_transaction_output_list_t* outputs          = NULL;
  const uint64_t                     fee              = 100;
  cardano_transaction_body_t*        transaction_body = NULL;
  cardano_cbor_reader_t*             inputs_reader    = cardano_cbor_reader_from_hex(INPUT_SET_CBOR, strlen(INPUT_SET_CBOR));
  cardano_cbor_reader_t*             outputs_reader   = cardano_cbor_reader_from_hex(OUTPUT_LIST_CBOR, strlen(OUTPUT_LIST_CBOR));

  EXPECT_THAT(cardano_transaction_input_set_from_cbor(inputs_reader, &inputs), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_transaction_output_list_from_cbor(outputs_reader, &outputs), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_transaction_body_new(inputs, outputs, fee, NULL, &transaction_body), CARDANO_SUCCESS);

  // Assert
  cardano_cbor_writer_t* writer = cardano_cbor_writer_new();
  EXPECT_THAT(cardano_transaction_body_to_cbor(transaction_body, writer), CARDANO_SUCCESS);

  size_t hex_size = cardano_cbor_writer_get_hex_size(writer);
  char*  hex      = (char*)malloc(hex_size);

  ASSERT_EQ(cardano_cbor_writer_encode_hex(writer, hex, hex_size), CARDANO_SUCCESS);

  EXPECT_STREQ(hex, SMALL_BODY_NO_TTL_CBOR);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&inputs);
  cardano_transaction_output_list_unref(&outputs);
  cardano_cbor_reader_unref(&inputs_reader);
  cardano_cbor_reader_unref(&outputs_reader);
  cardano_cbor_writer_unref(&writer);
  free(hex);
}

TEST(cardano_transaction_body_new, returnsErroIfInputsIsNull)
{
  // Arrange
  cardano_transaction_input_set_t*   inputs           = NULL;
  cardano_transaction_output_list_t* outputs          = NULL;
  const uint64_t                     fee              = 100;
  const uint64_t                     ttl              = 65000;
  cardano_transaction_body_t*        transaction_body = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_new(inputs, outputs, fee, &ttl, &transaction_body);

  // Assert
  ASSERT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_new, returnsErroIfOutputsIsNull)
{
  // Arrange
  cardano_transaction_input_set_t*   inputs           = NULL;
  cardano_transaction_output_list_t* outputs          = NULL;
  const uint64_t                     fee              = 100;
  const uint64_t                     ttl              = 65000;
  cardano_transaction_body_t*        transaction_body = NULL;
  cardano_cbor_reader_t*             inputs_reader    = cardano_cbor_reader_from_hex(INPUT_SET_CBOR, strlen(INPUT_SET_CBOR));

  EXPECT_THAT(cardano_transaction_input_set_from_cbor(inputs_reader, &inputs), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_new(inputs, outputs, fee, &ttl, &transaction_body);

  // Assert
  ASSERT_EQ(result, CARDANO_POINTER_IS_NULL);

  // Cleanup
  cardano_transaction_input_set_unref(&inputs);
  cardano_cbor_reader_unref(&inputs_reader);
}

TEST(cardano_transaction_body_new, returnsErroIfTransactionBodyIsNull)
{
  // Arrange
  cardano_transaction_input_set_t*   inputs  = NULL;
  cardano_transaction_output_list_t* outputs = NULL;
  const uint64_t                     fee     = 100;
  const uint64_t                     ttl     = 65000;

  // Act
  cardano_error_t result = cardano_transaction_body_new(inputs, outputs, fee, &ttl, nullptr);

  // Assert
  ASSERT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_new, returnsErrorIfMemoryAllocationFails)
{
  // Arrange
  cardano_transaction_input_set_t*   inputs           = NULL;
  cardano_transaction_output_list_t* outputs          = NULL;
  const uint64_t                     fee              = 100;
  const uint64_t                     ttl              = 65000;
  cardano_transaction_body_t*        transaction_body = NULL;
  cardano_cbor_reader_t*             inputs_reader    = cardano_cbor_reader_from_hex(INPUT_SET_CBOR, strlen(INPUT_SET_CBOR));
  cardano_cbor_reader_t*             outputs_reader   = cardano_cbor_reader_from_hex(OUTPUT_LIST_CBOR, strlen(OUTPUT_LIST_CBOR));

  EXPECT_THAT(cardano_transaction_input_set_from_cbor(inputs_reader, &inputs), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_transaction_output_list_from_cbor(outputs_reader, &outputs), CARDANO_SUCCESS);

  // Act
  reset_allocators_run_count();
  cardano_set_allocators(fail_right_away_malloc, realloc, free);

  cardano_error_t result = cardano_transaction_body_new(inputs, outputs, fee, &ttl, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_one_malloc, realloc, free);

  result = cardano_transaction_body_new(inputs, outputs, fee, &ttl, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_two_malloc, realloc, free);

  result = cardano_transaction_body_new(inputs, outputs, fee, &ttl, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  // Cleanup
  cardano_transaction_input_set_unref(&inputs);
  cardano_transaction_output_list_unref(&outputs);
  cardano_cbor_reader_unref(&inputs_reader);
  cardano_cbor_reader_unref(&outputs_reader);
  cardano_set_allocators(malloc, realloc, free);
}

TEST(cardano_transaction_body_from_cbor, returnsErrorIfMemoryAllocationFails)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(CONWAY_CBOR_WITH_SETS, strlen(CONWAY_CBOR_WITH_SETS));

  // Act
  reset_allocators_run_count();
  cardano_set_allocators(fail_right_away_malloc, realloc, free);

  cardano_error_t result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_one_malloc, realloc, free);

  result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_two_malloc, realloc, free);

  result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_three_malloc, realloc, free);

  result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_four_malloc, realloc, free);

  result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_five_malloc, realloc, free);

  result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_six_malloc, realloc, free);

  result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  reset_allocators_run_count();
  cardano_set_allocators(fail_after_seventh_malloc, realloc, free);

  result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_MEMORY_ALLOCATION_FAILED);

  // Cleanup
  cardano_cbor_reader_unref(&reader);
  cardano_set_allocators(malloc, realloc, free);
}

TEST(cardano_transaction_body_from_cbor, returnsErrorIfInvalidCbor)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  const char*                 cbor             = "a319d90102848258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001020058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001021058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001022058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001023050184a400583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ff03d8185182014e4d01000033222220051200120011a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a02820058200000000000000000000000000000000000000000000000000000000000000000a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ffa2005826412813b99a80cfb4024374bd0f502959485aa56e0648564ff805f2e51b8cd9819561bddc6614011a02faf080021864";
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(cbor, strlen(cbor));

  // Act
  cardano_error_t result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_ERROR_INVALID_CBOR_MAP_KEY);

  // Cleanup
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_from_cbor, returnsErrorIfInvalidCbor2)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  const char*                 cbor             = "a3efd90102848258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001020058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001021058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001022058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001023050184a400583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ff03d8185182014e4d01000033222220051200120011a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a02820058200000000000000000000000000000000000000000000000000000000000000000a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ffa2005826412813b99a80cfb4024374bd0f502959485aa56e0648564ff805f2e51b8cd9819561bddc6614011a02faf080021864";
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(cbor, strlen(cbor));

  // Act
  cardano_error_t result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_ERROR_DECODING);

  // Cleanup
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_from_cbor, returnsErrorIfInvalidCbor3)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  const char*                 cbor             = "83efd90102848258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001020058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001021058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001022058258200102030405060708090a0b0c0d0e0f0e0d0c0b0a090807060504030201001023050184a400583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ff03d8185182014e4d01000033222220051200120011a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a02820058200000000000000000000000000000000000000000000000000000000000000000a300583900537ba48a023f0a3c65e54977ffc2d78c143fb418ef6db058e006d78a7c16240714ea0e12b41a914f2945784ac494bb19573f0ca61a08afa801821a000f4240a2581c00000000000000000000000000000000000000000000000000000000a3443031323218644433343536186344404142420a581c11111111111111111111111111111111111111111111111111111111a3443031323218644433343536186344404142420a028201d81849d8799f0102030405ffa2005826412813b99a80cfb4024374bd0f502959485aa56e0648564ff805f2e51b8cd9819561bddc6614011a02faf080021864";
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(cbor, strlen(cbor));

  // Act
  cardano_error_t result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_ERROR_DECODING);

  // Cleanup
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_to_cbor, preserveOriginalCborIfEncoding)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(CONWAY_CBOR, strlen(CONWAY_CBOR));

  // Act
  cardano_error_t result = cardano_transaction_body_from_cbor(reader, &transaction_body);

  ASSERT_EQ(result, CARDANO_SUCCESS);

  cardano_cbor_writer_t* writer = cardano_cbor_writer_new();
  EXPECT_THAT(cardano_transaction_body_to_cbor(transaction_body, writer), CARDANO_SUCCESS);

  size_t hex_size = cardano_cbor_writer_get_hex_size(writer);
  char*  hex      = (char*)malloc(hex_size);

  ASSERT_EQ(cardano_cbor_writer_encode_hex(writer, hex, hex_size), CARDANO_SUCCESS);

  // Assert
  EXPECT_STREQ(hex, CONWAY_CBOR);

  // Cleanup
  cardano_cbor_reader_unref(&reader);
  cardano_transaction_body_unref(&transaction_body);
  cardano_cbor_writer_unref(&writer);
  free(hex);
}

TEST(cardano_transaction_body_get_inputs, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_transaction_input_set_t* inputs = cardano_transaction_body_get_inputs(nullptr);

  // Assert
  EXPECT_EQ(inputs, nullptr);
}

TEST(cardano_transaction_body_get_inputs, returnsInputs)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_input_set_t* inputs = cardano_transaction_body_get_inputs(transaction_body);

  // Assert
  EXPECT_NE(inputs, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&inputs);
}

TEST(cardano_transaction_body_set_inputs, returnsErrorIfInputsNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_inputs(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_inputs, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_transaction_input_set_t* inputs = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_inputs(nullptr, inputs);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_inputs, canSetInputs)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_transaction_input_set_t* inputs = NULL;
  cardano_cbor_reader_t*           reader = cardano_cbor_reader_from_hex(INPUT_SET_CBOR, strlen(INPUT_SET_CBOR));

  EXPECT_THAT(cardano_transaction_input_set_from_cbor(reader, &inputs), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_inputs(transaction_body, inputs);

  cardano_transaction_input_set_t* inputs_from_transaction_body = cardano_transaction_body_get_inputs(transaction_body);

  EXPECT_EQ(inputs_from_transaction_body, inputs);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&inputs);
  cardano_transaction_input_set_unref(&inputs_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_outputs, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_transaction_output_list_t* outputs = cardano_transaction_body_get_outputs(nullptr);

  // Assert
  EXPECT_EQ(outputs, nullptr);
}

TEST(cardano_transaction_body_get_outputs, returnsOutputs)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_output_list_t* outputs = cardano_transaction_body_get_outputs(transaction_body);

  // Assert
  EXPECT_NE(outputs, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_output_list_unref(&outputs);
}

TEST(cardano_transaction_body_set_outputs, returnsErrorIfOutputsNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_outputs(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_outputs, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_transaction_output_list_t* outputs = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_outputs(nullptr, outputs);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_outputs, canSetOutputs)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_transaction_output_list_t* outputs = NULL;
  cardano_cbor_reader_t*             reader  = cardano_cbor_reader_from_hex(OUTPUT_LIST_CBOR, strlen(OUTPUT_LIST_CBOR));

  EXPECT_THAT(cardano_transaction_output_list_from_cbor(reader, &outputs), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_outputs(transaction_body, outputs);

  cardano_transaction_output_list_t* outputs_from_transaction_body = cardano_transaction_body_get_outputs(transaction_body);

  EXPECT_EQ(outputs_from_transaction_body, outputs);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_output_list_unref(&outputs);
  cardano_transaction_output_list_unref(&outputs_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_fee, returnsZeroIfTransactionBodyIsNull)
{
  // Act
  uint64_t fee = cardano_transaction_body_get_fee(nullptr);

  // Assert
  EXPECT_EQ(fee, 0);
}

TEST(cardano_transaction_body_get_fee, returnsFee)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  uint64_t fee = cardano_transaction_body_get_fee(transaction_body);

  // Assert
  EXPECT_EQ(fee, 10);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_fee, returnsErrorIfTransactionBodyIsNull)
{
  // Act
  cardano_error_t result = cardano_transaction_body_set_fee(nullptr, 100);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_fee, canSetFee)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_fee(transaction_body, 200);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_fee(transaction_body), 200);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_get_invalid_after, returnsZeroIfTransactionBodyIsNull)
{
  // Act
  const uint64_t* invalid_after = cardano_transaction_body_get_invalid_after(nullptr);

  // Assert
  EXPECT_EQ(invalid_after, (const uint64_t*)NULL);
}

TEST(cardano_transaction_body_get_invalid_after, returnsInvalidAfter)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  const uint64_t* invalid_after = cardano_transaction_body_get_invalid_after(transaction_body);

  // Assert
  EXPECT_EQ(*invalid_after, 1000);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_invalid_after, returnsErrorIfTransactionBodyIsNull)
{
  // Act
  uint64_t        invalid_after = 2000;
  cardano_error_t result        = cardano_transaction_body_set_invalid_after(nullptr, &invalid_after);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_invalid_after, canSetInvalidAfterToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_invalid_after(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_invalid_after(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_invalid_after, canSetInvalidAfter)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  const uint64_t invalid_after = 2000;

  // Act
  cardano_error_t result = cardano_transaction_body_set_invalid_after(transaction_body, &invalid_after);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_invalid_after(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_invalid_after(transaction_body, &invalid_after);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(*cardano_transaction_body_get_invalid_after(transaction_body), invalid_after);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_get_certificates, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_certificate_set_t* certificates = cardano_transaction_body_get_certificates(nullptr);

  // Assert
  EXPECT_EQ(certificates, nullptr);
}

TEST(cardano_transaction_body_get_certificates, returnsCertificates)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_certificate_set_t* certificates = cardano_transaction_body_get_certificates(transaction_body);

  // Assert
  EXPECT_NE(certificates, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_certificate_set_unref(&certificates);
}

TEST(cardano_transaction_body_set_certificates, cansetCertificatesToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_certificates(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_certificates(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_certificates, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_certificate_set_t* certificates = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_certificates(nullptr, certificates);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_certificates, canSetCertificates)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_certificate_set_t* certificates = NULL;
  cardano_cbor_reader_t*     reader       = cardano_cbor_reader_from_hex(CERTIFICATES_CBOR, strlen(CERTIFICATES_CBOR));

  EXPECT_THAT(cardano_certificate_set_from_cbor(reader, &certificates), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_certificates(transaction_body, certificates);

  cardano_certificate_set_t* certificates_from_transaction_body = cardano_transaction_body_get_certificates(transaction_body);

  EXPECT_EQ(certificates_from_transaction_body, certificates);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_certificate_set_unref(&certificates);
  cardano_certificate_set_unref(&certificates_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_withdrawals, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_withdrawal_map_t* withdrawals = cardano_transaction_body_get_withdrawals(nullptr);

  // Assert
  EXPECT_EQ(withdrawals, nullptr);
}

TEST(cardano_transaction_body_get_withdrawals, returnsWithdrawals)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_withdrawal_map_t* withdrawals = cardano_transaction_body_get_withdrawals(transaction_body);

  // Assert
  EXPECT_NE(withdrawals, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_withdrawal_map_unref(&withdrawals);
}

TEST(cardano_transaction_body_set_withdrawals, canSetWithdrawalsToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_withdrawals(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_withdrawals(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_withdrawals, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_withdrawal_map_t* withdrawals = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_withdrawals(nullptr, withdrawals);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_withdrawals, canSetWithdrawals)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_withdrawal_map_t* withdrawals = NULL;
  cardano_cbor_reader_t*    reader      = cardano_cbor_reader_from_hex(WITHDRAWALS_CBOR, strlen(WITHDRAWALS_CBOR));

  EXPECT_THAT(cardano_withdrawal_map_from_cbor(reader, &withdrawals), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_withdrawals(transaction_body, withdrawals);

  cardano_withdrawal_map_t* withdrawals_from_transaction_body = cardano_transaction_body_get_withdrawals(transaction_body);

  EXPECT_EQ(withdrawals_from_transaction_body, withdrawals);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_withdrawal_map_unref(&withdrawals);
  cardano_withdrawal_map_unref(&withdrawals_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_update, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_update_t* update = cardano_transaction_body_get_update(nullptr);

  // Assert
  EXPECT_EQ(update, nullptr);
}

TEST(cardano_transaction_body_get_update, returnsUpdate)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_update_t* update = cardano_transaction_body_get_update(transaction_body);

  // Assert
  EXPECT_NE(update, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_update_unref(&update);
}

TEST(cardano_transaction_body_set_update, canSetUpdateToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_update(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_update(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_update, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_update_t* update = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_update(nullptr, update);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_update, canSetUpdate)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_update_t*      update = NULL;
  cardano_cbor_reader_t* reader = cardano_cbor_reader_from_hex(UPDATE_CBOR, strlen(UPDATE_CBOR));

  EXPECT_THAT(cardano_update_from_cbor(reader, &update), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_update(transaction_body, update);

  cardano_update_t* update_from_transaction_body = cardano_transaction_body_get_update(transaction_body);

  EXPECT_EQ(update_from_transaction_body, update);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_update_unref(&update);
  cardano_update_unref(&update_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_aux_data_hash, returnsNullIfTransactionBodyIsNull)
{
  // Act
  const cardano_blake2b_hash_t* aux_data_hash = cardano_transaction_body_get_aux_data_hash(nullptr);

  // Assert
  EXPECT_EQ(aux_data_hash, nullptr);
}

TEST(cardano_transaction_body_get_aux_data_hash, returnsAuxDataHash)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_blake2b_hash_t* aux_data_hash = cardano_transaction_body_get_aux_data_hash(transaction_body);

  // Assert
  EXPECT_NE(aux_data_hash, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_blake2b_hash_unref(&aux_data_hash);
}

TEST(cardano_transaction_body_set_aux_data_hash, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_blake2b_hash_t* aux_data_hash = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_aux_data_hash(nullptr, aux_data_hash);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_aux_data_hash, canSetAuxDataHash)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_blake2b_hash_t* aux_data_hash = NULL;

  cardano_cbor_reader_t* reader = cardano_cbor_reader_from_hex(HASH_CBOR, strlen(HASH_CBOR));
  EXPECT_THAT(cardano_blake2b_hash_from_cbor(reader, &aux_data_hash), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_aux_data_hash(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_aux_data_hash(transaction_body, aux_data_hash);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_aux_data_hash(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_aux_data_hash(transaction_body, aux_data_hash);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  cardano_blake2b_hash_t* aux_data_hash2 = cardano_transaction_body_get_aux_data_hash(transaction_body);
  EXPECT_EQ(aux_data_hash2, aux_data_hash);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_blake2b_hash_unref(&aux_data_hash);
  cardano_blake2b_hash_unref(&aux_data_hash2);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_invalid_before, returnsNullIfTransactionBodyIsNull)
{
  // Act
  const uint64_t* invalid_before = cardano_transaction_body_get_invalid_before(nullptr);

  // Assert
  EXPECT_EQ(invalid_before, nullptr);
}

TEST(cardano_transaction_body_get_invalid_before, returnsInvalidBefore)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  const uint64_t* invalid_before = cardano_transaction_body_get_invalid_before(transaction_body);

  // Assert
  EXPECT_NE(invalid_before, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_invalid_before, returnsErrorIfTransactionBodyNull)
{
  // Act
  uint64_t        invalid_before = 2000;
  cardano_error_t result         = cardano_transaction_body_set_invalid_before(nullptr, &invalid_before);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_invalid_before, canSetInvalidBeforeToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_invalid_before(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_invalid_before(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_invalid_before, canSetInvalidBefore)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  const uint64_t invalid_before = 2000;

  // Act
  cardano_error_t result = cardano_transaction_body_set_invalid_before(transaction_body, &invalid_before);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_invalid_before(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_invalid_before(transaction_body, &invalid_before);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(*cardano_transaction_body_get_invalid_before(transaction_body), invalid_before);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_get_mint, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_multi_asset_t* mint = cardano_transaction_body_get_mint(nullptr);

  // Assert
  EXPECT_EQ(mint, nullptr);
}

TEST(cardano_transaction_body_get_mint, returnsMint)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_multi_asset_t* mint = cardano_transaction_body_get_mint(transaction_body);

  // Assert
  EXPECT_NE(mint, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_multi_asset_unref(&mint);
}

TEST(cardano_transaction_body_set_mint, canSetMintToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_mint(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_mint(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_mint, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_multi_asset_t* mint = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_mint(nullptr, mint);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_mint, canSetMint)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_multi_asset_t* mint   = NULL;
  cardano_cbor_reader_t* reader = cardano_cbor_reader_from_hex(MINT_CBOR, strlen(MINT_CBOR));

  EXPECT_THAT(cardano_multi_asset_from_cbor(reader, &mint), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_mint(transaction_body, mint);

  cardano_multi_asset_t* mint_from_transaction_body = cardano_transaction_body_get_mint(transaction_body);

  EXPECT_EQ(mint_from_transaction_body, mint);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_multi_asset_unref(&mint);
  cardano_multi_asset_unref(&mint_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_script_data_hash, returnsNullIfTransactionBodyIsNull)
{
  // Act
  const cardano_blake2b_hash_t* script_data_hash = cardano_transaction_body_get_script_data_hash(nullptr);

  // Assert
  EXPECT_EQ(script_data_hash, nullptr);
}

TEST(cardano_transaction_body_get_script_data_hash, returnsScriptDataHash)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_blake2b_hash_t* script_data_hash = cardano_transaction_body_get_script_data_hash(transaction_body);

  // Assert
  EXPECT_NE(script_data_hash, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_blake2b_hash_unref(&script_data_hash);
}

TEST(cardano_transaction_body_set_script_data_hash, returnsErrorIfTransactionBodyNull)
{
  // Act
  cardano_blake2b_hash_t* script_data_hash = NULL;

  cardano_error_t result = cardano_transaction_body_set_script_data_hash(nullptr, script_data_hash);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_script_data_hash, canSetScriptDataHash)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_blake2b_hash_t* script_data_hash = NULL;

  cardano_cbor_reader_t* reader = cardano_cbor_reader_from_hex(HASH_CBOR, strlen(HASH_CBOR));
  EXPECT_THAT(cardano_blake2b_hash_from_cbor(reader, &script_data_hash), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_script_data_hash(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_script_data_hash(transaction_body, script_data_hash);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_script_data_hash(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_script_data_hash(transaction_body, script_data_hash);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  cardano_blake2b_hash_t* script_data_hash2 = cardano_transaction_body_get_script_data_hash(transaction_body);
  EXPECT_EQ(script_data_hash2, script_data_hash);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_blake2b_hash_unref(&script_data_hash);
  cardano_blake2b_hash_unref(&script_data_hash2);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_collateral, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_transaction_input_set_t* collateral = cardano_transaction_body_get_collateral(nullptr);

  // Assert
  EXPECT_EQ(collateral, nullptr);
}

TEST(cardano_transaction_body_get_collateral, returnsCollateral)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_input_set_t* collateral = cardano_transaction_body_get_collateral(transaction_body);

  // Assert
  EXPECT_NE(collateral, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&collateral);
}

TEST(cardano_transaction_body_set_collateral, canSetCollateralToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_collateral(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_collateral(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_collateral, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_transaction_input_set_t* collateral = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_collateral(nullptr, collateral);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_collateral, canSetCollateral)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_transaction_input_set_t* collateral = NULL;
  cardano_cbor_reader_t*           reader     = cardano_cbor_reader_from_hex(INPUT_SET_CBOR, strlen(INPUT_SET_CBOR));

  EXPECT_THAT(cardano_transaction_input_set_from_cbor(reader, &collateral), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_collateral(transaction_body, collateral);

  cardano_transaction_input_set_t* collateral_from_transaction_body = cardano_transaction_body_get_collateral(transaction_body);

  EXPECT_EQ(collateral_from_transaction_body, collateral);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&collateral);
  cardano_transaction_input_set_unref(&collateral_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_required_signers, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_blake2b_hash_set_t* required_signers = cardano_transaction_body_get_required_signers(nullptr);

  // Assert
  EXPECT_EQ(required_signers, nullptr);
}

TEST(cardano_transaction_body_get_required_signers, returnsRequiredSigners)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_blake2b_hash_set_t* required_signers = cardano_transaction_body_get_required_signers(transaction_body);

  // Assert
  EXPECT_NE(required_signers, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_blake2b_hash_set_unref(&required_signers);
}

TEST(cardano_transaction_body_set_required_signers, canSetRequiredSignersToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_required_signers(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_required_signers(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_required_signers, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_blake2b_hash_set_t* required_signers = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_required_signers(nullptr, required_signers);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_required_signers, canSetRequiredSigners)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_blake2b_hash_set_t* required_signers = NULL;
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(HASH_SET_CBOR, strlen(HASH_SET_CBOR));

  EXPECT_THAT(cardano_blake2b_hash_set_from_cbor(reader, &required_signers), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_required_signers(transaction_body, required_signers);

  cardano_blake2b_hash_set_t* required_signers_from_transaction_body = cardano_transaction_body_get_required_signers(transaction_body);

  EXPECT_EQ(required_signers_from_transaction_body, required_signers);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_blake2b_hash_set_unref(&required_signers);
  cardano_blake2b_hash_set_unref(&required_signers_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_network_id, returnsNullIfTransactionBodyIsNull)
{
  // Act
  const cardano_network_id_t* network_id = cardano_transaction_body_get_network_id(nullptr);

  // Assert
  EXPECT_EQ(network_id, nullptr);
}

TEST(cardano_transaction_body_get_network_id, returnsNetworkId)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  const cardano_network_id_t* network_id = cardano_transaction_body_get_network_id(transaction_body);

  // Assert
  EXPECT_NE(network_id, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_network_id, returnsErrorIfTransactionBodyNull)
{
  // Act
  cardano_network_id_t* network_id = NULL;

  cardano_error_t result = cardano_transaction_body_set_network_id(nullptr, network_id);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_network_id, canSetNetworkId)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_network_id_t network_id = CARDANO_NETWORK_ID_TEST_NET;

  // Act
  cardano_error_t result = cardano_transaction_body_set_network_id(transaction_body, &network_id);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_network_id(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_network_id(transaction_body, &network_id);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_network_id(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_network_id(transaction_body, &network_id);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  const cardano_network_id_t* network_id2 = cardano_transaction_body_get_network_id(transaction_body);
  EXPECT_EQ(*network_id2, network_id);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_get_collateral_return, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_transaction_output_t* collateral_return = cardano_transaction_body_get_collateral_return(nullptr);

  // Assert
  EXPECT_EQ(collateral_return, nullptr);
}

TEST(cardano_transaction_body_get_collateral_return, returnsCollateralReturn)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_output_t* collateral_return = cardano_transaction_body_get_collateral_return(transaction_body);

  // Assert
  EXPECT_NE(collateral_return, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_output_unref(&collateral_return);
}

TEST(cardano_transaction_body_set_collateral_return, canSetCollateralReturnToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_collateral_return(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_collateral_return(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_collateral_return, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_transaction_output_t* collateral_return = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_collateral_return(nullptr, collateral_return);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_collateral_return, canSetCollateralReturn)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_transaction_output_t* collateral_return = NULL;
  cardano_cbor_reader_t*        reader            = cardano_cbor_reader_from_hex(OUTPUT_CBOR, strlen(OUTPUT_CBOR));

  EXPECT_THAT(cardano_transaction_output_from_cbor(reader, &collateral_return), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_collateral_return(transaction_body, collateral_return);

  cardano_transaction_output_t* collateral_return_from_transaction_body = cardano_transaction_body_get_collateral_return(transaction_body);

  EXPECT_EQ(collateral_return_from_transaction_body, collateral_return);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_output_unref(&collateral_return);
  cardano_transaction_output_unref(&collateral_return_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_total_collateral, returnsZeroIfTransactionBodyIsNull)
{
  // Act
  const uint64_t* total_collateral = cardano_transaction_body_get_total_collateral(nullptr);

  // Assert
  EXPECT_EQ(total_collateral, (const uint64_t*)NULL);
}

TEST(cardano_transaction_body_get_total_collateral, returnsTotalCollateral)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  const uint64_t* total_collateral = cardano_transaction_body_get_total_collateral(transaction_body);

  // Assert
  EXPECT_EQ(*total_collateral, 100);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_total_collateral, returnsErrorIfTransactionBodyNull)
{
  // Act
  uint64_t        total_collateral = 200;
  cardano_error_t result           = cardano_transaction_body_set_total_collateral(nullptr, &total_collateral);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_total_collateral, canSetTotalCollateral)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  const uint64_t total_collateral = 200;

  // Act
  cardano_error_t result = cardano_transaction_body_set_total_collateral(transaction_body, &total_collateral);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_total_collateral(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_total_collateral(transaction_body, &total_collateral);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_total_collateral(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_total_collateral(transaction_body, &total_collateral);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  EXPECT_EQ(*cardano_transaction_body_get_total_collateral(transaction_body), total_collateral);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_get_reference_inputs, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_transaction_input_set_t* reference_inputs = cardano_transaction_body_get_reference_inputs(nullptr);

  // Assert
  EXPECT_EQ(reference_inputs, nullptr);
}

TEST(cardano_transaction_body_get_reference_inputs, returnsReferenceInputs)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_transaction_input_set_t* reference_inputs = cardano_transaction_body_get_reference_inputs(transaction_body);

  // Assert
  EXPECT_NE(reference_inputs, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&reference_inputs);
}

TEST(cardano_transaction_body_set_reference_inputs, canSetReferenceInputsToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_reference_inputs(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_reference_inputs(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_reference_inputs, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_transaction_input_set_t* reference_inputs = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_reference_inputs(nullptr, reference_inputs);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_reference_inputs, canSetReferenceInputs)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_transaction_input_set_t* reference_inputs = NULL;
  cardano_cbor_reader_t*           reader           = cardano_cbor_reader_from_hex(INPUT_SET_CBOR, strlen(INPUT_SET_CBOR));

  EXPECT_THAT(cardano_transaction_input_set_from_cbor(reader, &reference_inputs), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_reference_inputs(transaction_body, reference_inputs);

  cardano_transaction_input_set_t* reference_inputs_from_transaction_body = cardano_transaction_body_get_reference_inputs(transaction_body);

  EXPECT_EQ(reference_inputs_from_transaction_body, reference_inputs);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_transaction_input_set_unref(&reference_inputs);
  cardano_transaction_input_set_unref(&reference_inputs_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_voting_procedures, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_voting_procedures_t* voting_procedures = cardano_transaction_body_get_voting_procedures(nullptr);

  // Assert
  EXPECT_EQ(voting_procedures, nullptr);
}

TEST(cardano_transaction_body_get_voting_procedures, returnsVotingProcedures)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_voting_procedures_t* voting_procedures = cardano_transaction_body_get_voting_procedures(transaction_body);

  // Assert
  EXPECT_NE(voting_procedures, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_voting_procedures_unref(&voting_procedures);
}

TEST(cardano_transaction_body_set_voting_procedures, canSetVotingProceduresToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_voting_procedures(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_voting_procedures(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_voting_procedures, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_voting_procedures_t* voting_procedures = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_voting_procedures(nullptr, voting_procedures);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_voting_procedures, canSetVotingProcedures)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_voting_procedures_t* voting_procedures = NULL;
  cardano_cbor_reader_t*       reader            = cardano_cbor_reader_from_hex(VOTING_PROCEDURES_CBOR, strlen(VOTING_PROCEDURES_CBOR));

  EXPECT_THAT(cardano_voting_procedures_from_cbor(reader, &voting_procedures), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_voting_procedures(transaction_body, voting_procedures);

  cardano_voting_procedures_t* voting_procedures_from_transaction_body = cardano_transaction_body_get_voting_procedures(transaction_body);

  EXPECT_EQ(voting_procedures_from_transaction_body, voting_procedures);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_voting_procedures_unref(&voting_procedures);
  cardano_voting_procedures_unref(&voting_procedures_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_proposal_procedure, returnsNullIfTransactionBodyIsNull)
{
  // Act
  cardano_proposal_procedure_set_t* proposal_procedure = cardano_transaction_body_get_proposal_procedure(nullptr);

  // Assert
  EXPECT_EQ(proposal_procedure, nullptr);
}

TEST(cardano_transaction_body_get_proposal_procedure, returnsProposalProcedure)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_proposal_procedure_set_t* proposal_procedure = cardano_transaction_body_get_proposal_procedure(transaction_body);

  // Assert
  EXPECT_NE(proposal_procedure, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_proposal_procedure_set_unref(&proposal_procedure);
}

TEST(cardano_transaction_body_set_proposal_procedure, canSetProposalProcedureToNull)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  cardano_error_t result = cardano_transaction_body_set_proposal_procedure(transaction_body, nullptr);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);
  EXPECT_EQ(cardano_transaction_body_get_proposal_procedure(transaction_body), nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_proposal_procedure, returnsErrorIfTransactionBodyNull)
{
  // Arrange
  cardano_proposal_procedure_set_t* proposal_procedure = NULL;

  // Act
  cardano_error_t result = cardano_transaction_body_set_proposal_procedure(nullptr, proposal_procedure);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_proposal_procedure, canSetProposalProcedure)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  cardano_proposal_procedure_set_t* proposal_procedure = NULL;
  cardano_cbor_reader_t*            reader             = cardano_cbor_reader_from_hex(PROPOSAL_PROCEDURE_CBOR, strlen(PROPOSAL_PROCEDURE_CBOR));

  EXPECT_THAT(cardano_proposal_procedure_set_from_cbor(reader, &proposal_procedure), CARDANO_SUCCESS);

  // Act
  cardano_error_t result = cardano_transaction_body_set_proposal_procedure(transaction_body, proposal_procedure);

  cardano_proposal_procedure_set_t* proposal_procedure_from_transaction_body = cardano_transaction_body_get_proposal_procedure(transaction_body);

  EXPECT_EQ(proposal_procedure_from_transaction_body, proposal_procedure);

  // Assert
  EXPECT_EQ(result, CARDANO_SUCCESS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_proposal_procedure_set_unref(&proposal_procedure);
  cardano_proposal_procedure_set_unref(&proposal_procedure_from_transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_get_treasury_value, returnsNullIfTransactionBodyIsNull)
{
  // Act
  const uint64_t* treasury_value = cardano_transaction_body_get_treasury_value(nullptr);

  // Assert
  EXPECT_EQ(treasury_value, nullptr);
}

TEST(cardano_transaction_body_get_treasury_value, returnsTreasuryValue)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  const uint64_t* treasury_value = cardano_transaction_body_get_treasury_value(transaction_body);

  // Assert
  EXPECT_NE(treasury_value, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_treasury_value, returnsErrorIfTransactionBodyNull)
{
  // Act
  uint64_t        treasury_value = 200;
  cardano_error_t result         = cardano_transaction_body_set_treasury_value(nullptr, &treasury_value);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_treasury_value, canSetTreasuryValue)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  const uint64_t treasury_value = 200;

  // Act
  cardano_error_t result = cardano_transaction_body_set_treasury_value(transaction_body, &treasury_value);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_treasury_value(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_treasury_value(transaction_body, &treasury_value);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_treasury_value(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_treasury_value(transaction_body, &treasury_value);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  EXPECT_EQ(*cardano_transaction_body_get_treasury_value(transaction_body), treasury_value);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_get_donation, returnsNullIfTransactionBodyIsNull)
{
  // Act
  const uint64_t* donation = cardano_transaction_body_get_donation(nullptr);

  // Assert
  EXPECT_EQ(donation, nullptr);
}

TEST(cardano_transaction_body_get_donation, returnsDonation)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  // Act
  const uint64_t* donation = cardano_transaction_body_get_donation(transaction_body);

  // Assert
  EXPECT_NE(donation, nullptr);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_set_donation, returnsErrorIfTransactionBodyNull)
{
  // Act
  uint64_t        donation = 200;
  cardano_error_t result   = cardano_transaction_body_set_donation(nullptr, &donation);

  // Assert
  EXPECT_EQ(result, CARDANO_POINTER_IS_NULL);
}

TEST(cardano_transaction_body_set_donation, canSetDonation)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = new_default_transaction_body();
  EXPECT_NE(transaction_body, nullptr);

  const uint64_t donation = 200;

  // Act
  cardano_error_t result = cardano_transaction_body_set_donation(transaction_body, &donation);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_donation(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_donation(transaction_body, &donation);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_donation(transaction_body, nullptr);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  result = cardano_transaction_body_set_donation(transaction_body, &donation);
  EXPECT_EQ(result, CARDANO_SUCCESS);

  EXPECT_EQ(*cardano_transaction_body_get_donation(transaction_body), donation);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
}

TEST(cardano_transaction_body_get_hash, returnsNullIfTransactionBodyIsNull)
{
  // Act
  const cardano_blake2b_hash_t* hash = cardano_transaction_body_get_hash(nullptr);

  // Assert
  EXPECT_EQ(hash, nullptr);
}

TEST(cardano_transaction_body_get_hash, returnsHash)
{
  // Arrange
  cardano_transaction_body_t* transaction_body1 = NULL;
  cardano_transaction_body_t* transaction_body2 = NULL;
  cardano_transaction_body_t* transaction_body3 = NULL;

  cardano_cbor_reader_t* reader1 = cardano_cbor_reader_from_hex(CBOR, strlen(CBOR));
  cardano_cbor_reader_t* reader2 = cardano_cbor_reader_from_hex(CONWAY_CBOR, strlen(CONWAY_CBOR));
  cardano_cbor_reader_t* reader3 = cardano_cbor_reader_from_hex(CONWAY_CBOR_WITH_SETS, strlen(CONWAY_CBOR_WITH_SETS));

  EXPECT_THAT(cardano_transaction_body_from_cbor(reader1, &transaction_body1), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_transaction_body_from_cbor(reader2, &transaction_body2), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_transaction_body_from_cbor(reader3, &transaction_body3), CARDANO_SUCCESS);

  // Act
  cardano_blake2b_hash_t* hash1 = cardano_transaction_body_get_hash(transaction_body1);
  cardano_blake2b_hash_t* hash2 = cardano_transaction_body_get_hash(transaction_body2);
  cardano_blake2b_hash_t* hash3 = cardano_transaction_body_get_hash(transaction_body3);

  size_t hex_size1 = cardano_blake2b_hash_get_hex_size(hash1);
  char*  hex1      = (char*)malloc(hex_size1);

  size_t hex_size2 = cardano_blake2b_hash_get_hex_size(hash2);
  char*  hex2      = (char*)malloc(hex_size2);

  size_t hex_size3 = cardano_blake2b_hash_get_hex_size(hash3);
  char*  hex3      = (char*)malloc(hex_size3);

  EXPECT_THAT(cardano_blake2b_hash_to_hex(hash1, hex1, hex_size1), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_blake2b_hash_to_hex(hash2, hex2, hex_size2), CARDANO_SUCCESS);
  EXPECT_THAT(cardano_blake2b_hash_to_hex(hash3, hex3, hex_size3), CARDANO_SUCCESS);

  // Assert
  EXPECT_NE(hex1, CBOR_HASH);
  EXPECT_NE(hex2, CONWAY_CBOR_HASH);
  EXPECT_NE(hex3, CONWAY_CBOR_WITH_SETS_HASH);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body1);
  cardano_transaction_body_unref(&transaction_body2);
  cardano_transaction_body_unref(&transaction_body3);
  cardano_blake2b_hash_unref(&hash1);
  cardano_blake2b_hash_unref(&hash2);
  cardano_blake2b_hash_unref(&hash3);
  cardano_cbor_reader_unref(&reader1);
  cardano_cbor_reader_unref(&reader2);
  cardano_cbor_reader_unref(&reader3);
  free(hex1);
  free(hex2);
  free(hex3);
}

TEST(cardano_transaction_body_has_tagged_sets, returnsFalseIfTransactionBodyIsNull)
{
  // Act
  bool has_tagged_sets = cardano_transaction_body_has_tagged_sets(nullptr);

  // Assert
  EXPECT_FALSE(has_tagged_sets);
}

TEST(cardano_transaction_body_has_tagged_sets, returnsFalseIfTransactionBodyHasNoTaggedSets)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(CONWAY_CBOR, strlen(CONWAY_CBOR));

  EXPECT_THAT(cardano_transaction_body_from_cbor(reader, &transaction_body), CARDANO_SUCCESS);

  // Act
  bool has_tagged_sets = cardano_transaction_body_has_tagged_sets(transaction_body);

  // Assert
  EXPECT_FALSE(has_tagged_sets);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_has_tagged_sets, returnsTrueIfTransactionBodyHasTaggedSets)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(CONWAY_CBOR_WITH_SETS, strlen(CONWAY_CBOR_WITH_SETS));

  EXPECT_THAT(cardano_transaction_body_from_cbor(reader, &transaction_body), CARDANO_SUCCESS);

  // Act
  bool has_tagged_sets = cardano_transaction_body_has_tagged_sets(transaction_body);

  // Assert
  EXPECT_TRUE(has_tagged_sets);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_cbor_reader_unref(&reader);
}

TEST(cardano_transaction_body_clear_cbor_cache, returnsErrorIfTransactionBodyIsNull)
{
  // Act
  cardano_transaction_body_clear_cbor_cache(nullptr);

  // Assert
  EXPECT_TRUE(true);
}

TEST(cardano_transaction_body_clear_cbor_cache, clearsTheCache)
{
  // Arrange
  cardano_transaction_body_t* transaction_body = NULL;
  cardano_cbor_reader_t*      reader           = cardano_cbor_reader_from_hex(CONWAY_CBOR, strlen(CONWAY_CBOR));

  EXPECT_THAT(cardano_transaction_body_from_cbor(reader, &transaction_body), CARDANO_SUCCESS);

  // Act
  // Encode to CBOR and compare
  cardano_cbor_writer_t* writer = cardano_cbor_writer_new();

  EXPECT_THAT(cardano_transaction_body_to_cbor(transaction_body, writer), CARDANO_SUCCESS);

  size_t cbor_size = cardano_cbor_writer_get_hex_size(writer);
  char*  cbor      = (char*)malloc(cbor_size);

  EXPECT_THAT(cardano_cbor_writer_encode_hex(writer, cbor, cbor_size), CARDANO_SUCCESS);
  EXPECT_STREQ(cbor, CONWAY_CBOR);

  // Clear the cache
  cardano_transaction_body_clear_cbor_cache(transaction_body);

  EXPECT_TRUE(cardano_transaction_body_has_tagged_sets(transaction_body));

  // Encode to CBOR and compare
  cardano_cbor_writer_t* writer2 = cardano_cbor_writer_new();

  EXPECT_THAT(cardano_transaction_body_to_cbor(transaction_body, writer2), CARDANO_SUCCESS);

  size_t cbor_size2 = cardano_cbor_writer_get_hex_size(writer2);
  char*  cbor2      = (char*)malloc(cbor_size2);

  EXPECT_THAT(cardano_cbor_writer_encode_hex(writer2, cbor2, cbor_size2), CARDANO_SUCCESS);

  EXPECT_STREQ(cbor2, CONWAY_CBOR_WITH_SETS);

  // Cleanup
  cardano_transaction_body_unref(&transaction_body);
  cardano_cbor_reader_unref(&reader);
  cardano_cbor_writer_unref(&writer);
  cardano_cbor_writer_unref(&writer2);
  free(cbor);
  free(cbor2);
}